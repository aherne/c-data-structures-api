(LATER) unit tests & benchmarks must be split into .h and .cpp
ALL:
	ITERATOR INVALIDATION
		list
			dynamic arrays
				whenever an element is removed
				whenever array resizes
			linked lists
				whenever an element is removed
			doubly linked list
				whenever an element is removed
		map
			doubly linked list hash map & hash map
				whenever an element is removed
				whenever buckets resize
			tree map
				whenever an element is removed
		set
			same
linkedhashmap
	(LATER) unique(valueComparator)
map
	(LATER) add keyComparator and valueComparator template args to all
	(LATER) unify sort test methods (since now iterators work the same)
set
	* (LATER) add valueComparator template arg to all
list
	+ create separate test cases for addToTop
		PHP: operator[] will always add to bottom!
	+ (LATER) unique(valueComparator)
	+ (LATER) remove @ iterator
FIX: sort has complexity 2N+logN (because changing tail requires full iteration)
BUG: @ArrayList: if one issues a DELETE on an item=> CRASH
==============================
iterator invalidation

------------------------------
GRAPH WITHOUT WEIGHTS
	HashTable<Vertex<VALUE>*> contents;
	
	template<typename VALUE>
	struct Vertex {
		VALUE data;
		ArrayList<Vertex<VALUE>*> edges;	
	}
GRAPH WITH WEIGHTS
	HashTable<Vertex<VALUE, WEIGHT>*> contents;
	
	template<typename VALUE, typename WEIGHT>
	struct Vertex {
		VALUE data;
		ArrayList<Edge<VALUE, WEIGHT>*> edges;	
	}
		
	template<typename VALUE>
	struct Edge {
		Vertex<VALUE>* vertex;
		WEIGHT weight;
	}
	
	// would be very fast to search vertex and find its edges
	// would be fast to update a vertex or edge
	// would be O(E) to delete an edge