(BUG): @ArrayList: if one issues a DELETE on an item=> CRASH

ALL:
	ITERATOR INVALIDATION
		list
			dynamic arrays
				whenever an element is removed
				whenever array resizes
			linked lists
				whenever an element is removed
			doubly linked list
				whenever an element is removed
		map
			doubly linked list hash map & hash map
				whenever an element is removed
				whenever buckets resize
			tree map
				whenever an element is removed
		set
			same
linkedhashmap
	(LATER) unique(valueComparator)
map
	(LATER) add keyComparator and valueComparator (?) template args to all
	(LATER) unify sort test methods (since now iterators work the same)
set
	* (LATER) add valueComparator template arg to all
list
	+ (LATER) unique(valueComparator)
	+ (LATER) remove @ iterator
FIX: sort has complexity 2N+logN (because changing tail requires full iteration)
ISSUE: @TreeNode 
- remove & removeBranch are problematic. If root node @ tree is removed, then a DELETE is issued => double-free. Maybe they should be user-level domain?
- current design imposes a single search full scan solution, which is unacceptable. Either encapsulate or remove the method. 
+ add UniqueValueTreeNode
? create a Tree interface maybe?
+ interators (VERY DIFFICULT)
==============================
GRAPH WITHOUT WEIGHTS
	HashTable<Vertex<VALUE>*> contents;
	
	template<typename VALUE>
	struct Vertex {
		VALUE data;
		ArrayList<Vertex<VALUE>*> edges;	
	}
GRAPH WITH WEIGHTS
	HashTable<Vertex<VALUE, WEIGHT>*> contents;
	
	template<typename VALUE, typename WEIGHT>
	struct Vertex {
		VALUE data;
		ArrayList<Edge<VALUE, WEIGHT>*> edges;	
	}
		
	template<typename VALUE>
	struct Edge {
		Vertex<VALUE>* vertex;
		WEIGHT weight;
	}