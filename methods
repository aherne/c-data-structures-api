template<typename T>
class List {
	virtual ~List()
	virtual const T& operator[](const size_t& index) const = 0
	virtual void clear() = 0
	virtual void addToTop(const T& value) = 0
	virtual void addToBottom(const T& value) = 0
	virtual const T& get(const size_t& index) const = 0
	virtual void set(const size_t& index, const T& value) = 0
	virtual void emplace(const size_t& index, const T& value) = 0
	virtual bool isEmpty() const = 0
	virtual const std::size_t& size() const = 0
	virtual bool containsIndex(const size_t& index) const = 0
	virtual bool containsValue(const T& value, int (*comparator)(const T&, const T&)) const = 0
	virtual void removeIndex(const size_t& index) = 0
	virtual void removeValue(const T& value, int (*comparator)(const T&, const T&)) = 0
	virtual ListIterator<T>* begin() = 0
	virtual ListIterator<T>* end() = 0
}

template<typename T>
class ListIterator {
	virtual ~ListIterator()
	virtual const T& operator*() = 0
	virtual void operator++() = 0
	bool operator!=(const ListIterator<T>& it)
}

template<typename T>
class ArrayList: public List<T> {
	ArrayList()
	ArrayList(const std::size_t& reservedSize)
	void sort(bool (*comparator) (const T&, const T&))
}

template<typename T>
class ArrayListIterator : public ListIterator<T> {
	ArrayListIterator(ArrayList<T>* list)
	ArrayListIterator(std::size_t total)
}

template<typename T>
class DoublyLinkedList: public List<T> {
	DoublyLinkedList()
	void sort(bool (*comparator) (const T&, const T&))
}

template<typename T>
class DoublyLinkedListIterator : public ListIterator<T>{
	DoublyLinkedListIterator(DoublyLinkedList<T>* list)
	DoublyLinkedListIterator(std::size_t total)
}

template<typename T>
class LinkedList: public List<T> {
	LinkedList()
	void sort(bool (*comparator) (const T&, const T&))
}

template<typename T>
class LinkedListIterator : public ListIterator<T>{
	LinkedListIterator(LinkedList<T>* list)
	LinkedListIterator(std::size_t total)
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

template<typename _KEY, typename _VALUE>
class Map {
	virtual ~Map()
	virtual void clear() = 0
	virtual bool containsKey(const _KEY&) const = 0
	virtual bool containsValue(const _VALUE&) const = 0
	virtual bool isEmpty() const = 0
	virtual const std::size_t& size() const = 0
	virtual const _VALUE& get(const _KEY&) const = 0
	virtual void set(const _KEY&, const _VALUE&) = 0
	virtual void removeKey(const _KEY&) = 0
	virtual void removeValue(const _VALUE&) = 0
	virtual MapIterator<_KEY,_VALUE>* begin() = 0
	virtual MapIterator<_KEY,_VALUE>* end() = 0
}

template<typename _KEY, typename _VALUE>
class MapIterator {
	MapIterator()
	virtual ~MapIterator()
	virtual const std::pair<_KEY, _VALUE> operator*() = 0
	virtual void operator++() = 0
	bool operator!=(const MapIterator<_KEY,_VALUE>& it)
}
template<typename _KEY, typename _VALUE>
struct MapEntry {
	_KEY key
	_VALUE value
}

template<typename _KEY, typename _VALUE, int (*compareByKey)(const KEY&, const KEY&)=comparator<KEY>, std::size_t (*hash)(const MapEntry<_KEY,_VALUE>&), int (*compareByValue)(const VALUE&, const VALUE&) = comparator<VALUE>>
class HashMap : public Map<_KEY,_VALUE> {
	HashMap()
	HashMap(const std::size_t& reservedSize)
}

template<typename _KEY, typename _VALUE)>
class HashMapIterator : public MapIterator<_KEY,_VALUE> {
	HashMapIterator(HashTable<MapEntry<_KEY,_VALUE>>* hashTable)
	HashMapIterator(std::size_t total)
}

template<typename _KEY, typename _VALUE, int (*compareByKey)(const KEY&, const KEY&)=comparator<KEY>, std::size_t (*hash)(const MapEntry<_KEY,_VALUE>&), int (*compareByValue)(const VALUE&, const VALUE&) = comparator<VALUE>>
class LinkedHashMap : public Map<_KEY,_VALUE> {
	LinkedHashMap(const std::size_t& reservedSize)
	LinkedHashMap()
	void sortByKey(bool (*comparator) (const _KEY&, const _KEY&))
	void sortByValue(bool (*comparator) (const _VALUE&, const _VALUE&))
}

template<typename _KEY, typename _VALUE)>
class LinkedHashMapIterator : public MapIterator<_KEY,_VALUE> {
	LinkedHashMapIterator(LinkedHashTable<MapEntry<_KEY,_VALUE>>* map)
	LinkedHashMapIterator(std::size_t total)
}

template<typename _KEY, typename _VALUE, int (*compareByKey)(const KEY&, const KEY&)=comparator<KEY>, int (*compareByValue)(const VALUE&, const VALUE&) = comparator<VALUE>>
class TreeMap : public Map<_KEY,_VALUE> {
	TreeMap()
}

template<typename _KEY, typename _VALUE)>
class TreeMapIterator : public MapIterator<_KEY,_VALUE> {
	TreeMapIterator(RedBlackTree<MapEntry<_KEY,_VALUE>>* tree)
	TreeMapIterator(std::size_t total)
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

template<typename T>
class SetIterator {
	SetIterator()
	virtual ~SetIterator()
	virtual const T& operator*() = 0
	virtual void operator++() = 0
	bool operator!=(const SetIterator<T>& it)
}

template<typename T>
class Set {
	virtual ~Set()
	virtual void clear() = 0
	virtual bool contains(const T& value) const = 0
	virtual bool isEmpty() const = 0
	virtual const std::size_t& size() const = 0
	virtual void add(const T& value) = 0
	virtual void remove(const T& value) = 0
	virtual SetIterator<T>* begin() = 0
	virtual SetIterator<T>* end() = 0
}

template<typename T, int (*compare)(const T&,const T&) = comparator<T>, std::size_t (*hash)(const T&) = comparator<T>>
class HashSet : public Set<T> {
	HashSet()
	HashSet(const std::size_t& reservedSize)
}

template<typename T>
class HashSetIterator : public SetIterator<T> {
	HashSetIterator(HashTable<T>* hashTable)
	HashSetIterator(std::size_t total)
}

template<typename T, int (*compare)(const T&,const T&) = comparator<T>, std::size_t (*hash)(const T&) = hasher<T>>
class LinkedHashSet : public Set<T> {
	LinkedHashSet()
	LinkedHashSet(const std::size_t& reservedSize)
	void sort(bool (*comparator) (const T&, const T&))
}

template<typename T>
class LinkedHashSetIterator : public SetIterator<T> {
	LinkedHashSetIterator(LinkedHashTable<T>* set)
	LinkedHashSetIterator(std::size_t total)
}

template<typename T, int (*compare)(const T&,const T&)>
class TreeSet : public Set<T> {
	TreeSet()
}

template<typename T>
class TreeSetIterator : public SetIterator<T> {
	TreeSetIterator(RedBlackTree<T>* tree)
	TreeSetIterator(std::size_t total)
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

template<typename T>
class Container {
	virtual ~Container()
	virtual void clear() = 0
	virtual const std::size_t& size() const = 0
	virtual bool isEmpty() const = 0
	virtual const T& peek() const = 0
	virtual T pop() = 0
	virtual void push(const T& item) = 0
}

template<typename T>
class Queue: public Container<T> {
	Queue()
}

template<typename T>
class Stack: public Container<T> {
	Stack()
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

template<typename T>
class TreeNode {
	TreeNode(const T& data)
	~TreeNode()
	void setParent(TreeNode<T>* parent)
	TreeNode<T>*& getParent()
	void setData(const T& data)
	const T& getData() const
	const std::vector<TreeNode<T>*>& getChildren()
	void addChild(TreeNode<T>*& node)
	void removeChild(TreeNode<T>*& node)
	void removeChildren()
	bool isDescendantOf(TreeNode<T>*& node)
	bool isAncestorOf(TreeNode<T>*& node) const
	TreeNode<T>* getRoot()
	std::vector<TreeNode<T>*> getAncestors()
	std::vector<TreeNode<T>*> getDescendants() const
	std::size_t getSize() const
	std::size_t getHeight() const
	std::size_t getDepth() const
}

template<typename T>
class Tree {
	explicit Tree(const T& data)
	virtual ~Tree()
	TreeNode<T>* getRoot()
	std::size_t getSize()
	std::size_t getHeight()
	virtual TreeNode<T>* createNode(const T& data, TreeNode<T>*& parent)
	virtual void removeNode(TreeNode<T>*& node)
	virtual void removeBranch(TreeNode<T>*& node)
}

template<typename T, int (*compare)(const T&, const T&) = comparator<T>, std::size_t (*hash)(const T&) = hasher<T>>
class UniqueTree : public Tree<T> {
	TreeNode<T>* search(const T& data)
	bool contains(const T& data) const
}

template<typename T, int (*compare)(const T&, const T&) = comparator<T>>
class NonUniqueTree : public Tree<T> {
	std::vector<TreeNode<T>*> search(const T& data)
	bool contains(const T& data) const
}

template<typename T>
class TreeNodeVisitor {
	virtual ~TreeNodeVisitor()

	virtual bool visit(TreeNode<T>*& element) = 0
}

template<typename T>
inline void PreOrderTreeIterator(TreeNode<T>* node, TreeNodeVisitor<T>* visitor)

template<typename T>
inline void PostOrderTreeIterator(TreeNode<T>* node, TreeNodeVisitor<T>* visitor)

template<typename T>
inline void LevelOrderTreeIterator(TreeNode<T>* root, TreeNodeVisitor<T>* visitor)

template<typename T>
inline void LevelOrderTreeIterator(TreeNode<T>* root, std::size_t depth, TreeNodeVisitor<T>* visitor)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
template<typename T>
class GraphVertex {
		GraphVertex(const T& data) 
		~GraphVertex()
		void setData(const T& data)
		const T& getData() const
		const std::vector<GraphVertex<T>*>& getEdges() const
		bool isEdge(GraphVertex<T>*& vertex) const
		void addEdge(GraphVertex<T>*& vertex)
		void removeEdge(GraphVertex<T>*& vertex)
};

template<typename T>
class Graph {
public:
	virtual ~Graph() {}
	virtual GraphVertex<T>* createVertex(const T& data) = 0;
	virtual void removeVertex(GraphVertex<T>*& vertex) = 0;
	virtual std::size_t getSize() const = 0;
	virtual bool isPath(GraphVertex<T>*& left, GraphVertex<T>*& right) const = 0;
	virtual std::size_t getDistance(GraphVertex<T>*& left, GraphVertex<T>*& right) const = 0;
	virtual std::vector<GraphVertex<T>*> getPath(GraphVertex<T>*& left, GraphVertex<T>*& right) const = 0;
};

template<typename T>
class NonUniqueGraph : public Graph<T> {
	bool contains(const T& data, int (*comparator)(const T&, const T&)) const;
	std::vector<GraphVertex<T>*> search(const T& data, int (*comparator)(const T&, const T&)) const;
};

template<typename T, int (*compare)(const T&, const T&), std::size_t (*hash)(const T&)>
class UniqueGraph : public Graph<T> {
	bool contains(const T& data) const;
	GraphVertex<T>* search(const T& data);
}

template<typename T>
class GraphVertexVisitor {
public:
	virtual ~GraphVertexVisitor(){};
	virtual void visit(GraphVertex<T>* const& element) = 0;
};


template<typename T>
inline void BreadthFirstSearchGraphIterator(GraphVertex<T>* vertex, GraphVertexVisitor<T>* visitor);

template<typename T>
inline void DepthFirstSearchGraphIterator(GraphVertex<T>* vertex, GraphVertexVisitor<T>* visitor);