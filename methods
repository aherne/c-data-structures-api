// Interface that defines operations one can perform on a LIST abstract data type
template<typename T>
class List {
	virtual ~List()
	virtual const T& operator[](const size_t& index) const = 0
	virtual void clear() = 0
	virtual void addToTop(const T& value) = 0
	virtual void addToBottom(const T& value) = 0
	virtual const T& get(const size_t& index) const = 0
	virtual void set(const size_t& index, const T& value) = 0
	virtual void emplace(const size_t& index, const T& value) = 0
	virtual bool isEmpty() const = 0
	virtual const std::size_t& size() const = 0
	virtual bool containsIndex(const size_t& index) const = 0
	virtual bool containsValue(const T& value) const = 0
	virtual void removeIndex(const size_t& index) = 0
	virtual void removeValue(const T& value) = 0
	virtual ListIterator<T>* begin() = 0
	virtual ListIterator<T>* end() = 0
}

// Abstract class that defines iteration prototype of a LIST abstract data type
template<typename T>
class ListIterator {
	virtual ~ListIterator()
	virtual const T& operator*() = 0
	virtual void operator++() = 0
	bool operator!=(const ListIterator<T>& it)
}

// Class that implements DYNAMIC ARRAY data structure on top of LIST abstract data type
template<typename T, int (*comparator)(const T&, const T&) = comparator<T>>
class ArrayList: public List<T> {
	ArrayList()
	ArrayList(const std::size_t& reservedSize)
	void sort(bool (*comparator) (const T&, const T&))
}

// Class that implements DYNAMIC ARRAY iteration on top of ListIterator
template<typename T>
class ArrayListIterator : public ListIterator<T> {
	ArrayListIterator(ArrayList<T>* list)
	ArrayListIterator(std::size_t total)
}

// Class that implements DOUBLY LINKED LIST data structure on top of LIST abstract data type
template<typename T, int (*comparator)(const T&, const T&) = comparator<T>>
class DoublyLinkedList: public List<T> {
	DoublyLinkedList()
	void sort(bool (*comparator) (const T&, const T&))
}

// Class that implements DOUBLY LINKED LIST iteration on top of ListIterator
template<typename T>
class DoublyLinkedListIterator : public ListIterator<T>{
	DoublyLinkedListIterator(DoublyLinkedList<T>* list)
	DoublyLinkedListIterator(std::size_t total)
}

// Class that implements LINKED LIST data structure on top of LIST abstract data type
template<typename T, int (*comparator)(const T&, const T&) = comparator<T>>
class LinkedList: public List<T> {
	LinkedList()
	void sort(bool (*comparator) (const T&, const T&))
}

// Class that implements LINKED LIST iteration on top of ListIterator
template<typename T>
class LinkedListIterator : public ListIterator<T>{
	LinkedListIterator(LinkedList<T>* list)
	LinkedListIterator(std::size_t total)
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Interface that defines operations one can perform on an ASSOCIATIVE ARRAY abstract data type
template<typename K, typename V>
class Map {
	virtual ~Map()
	virtual void clear() = 0
	virtual bool containsKey(const K&) const = 0
	virtual bool containsValue(const V&) const = 0
	virtual bool isEmpty() const = 0
	virtual const std::size_t& size() const = 0
	virtual const V& get(const K&) const = 0
	virtual void set(const K&, const V&) = 0
	virtual void removeKey(const K&) = 0
	virtual void removeValue(const V&) = 0
	virtual MapIterator<K,V>* begin() = 0
	virtual MapIterator<K,V>* end() = 0
}

// Abstract class that defines iteration prototype of an ASSOCIATIVE ARRAY abstract data type
template<typename K, typename V>
class MapIterator {
	MapIterator()
	virtual ~MapIterator()
	virtual const std::pair<K, V> operator*() = 0
	virtual void operator++() = 0
	bool operator!=(const MapIterator<K,V>& it)
}

// Struct that defines the key/value pair that typifies ASSOCIATIVE ARRAY entries
template<typename K, typename V>
struct MapEntry {
	K key;
	V value;
}

// Class that implements HASH TABLE data structure on top of ASSOCIATIVE ARRAY abstract data type
template<typename K, typename V, int (*compareByKey)(const K&, const K&) = comparator<K>, std::size_t (*hash)(const K&) = hash<K>, int (*compareByValue)(const V&, const V&) = comparator<V>>
class HashMap : public Map<K,V> {
	HashMap()
	HashMap(const std::size_t& reservedSize)
}

// Class that implements HASH TABLE iteration on top of MapIterator
template<typename K, typename V>
class HashMapIterator : public MapIterator<K,V> {
	HashMapIterator(HashTable<MapEntry<K,V>>* hashTable)
	HashMapIterator(std::size_t total)
}

// Class that implements "LINKED" HASH TABLE data structure (a HASH TABLE backed by a DOUBLY LINKED LIST to allow predictable iteration order) on top of ASSOCIATIVE ARRAY abstract data type
template<typename K, typename V, int (*compareByKey)(const K&, const K&) = comparator<K>, std::size_t (*hash)(const K&) = hash<K>, int (*compareByValue)(const V&, const V&) = comparator<V>>
class LinkedHashMap : public Map<K,V> {
	LinkedHashMap(const std::size_t& reservedSize)
	LinkedHashMap()
	void sortByKey(bool (*comparator) (const K&, const K&))
	void sortByValue(bool (*comparator) (const V&, const V&))
}

// Class that implements "LINKED" HASH TABLE iteration on top of MapIterator
template<typename K, typename V)>
class LinkedHashMapIterator : public MapIterator<K,V> {
	LinkedHashMapIterator(LinkedHashTable<MapEntry<K,V>>* map)
	LinkedHashMapIterator(std::size_t total)
}

// Class that implements RED BLACK TREE data structure on top of ASSOCIATIVE ARRAY abstract data type
template<typename K, typename V, int (*compareByKey)(const K&, const K&) = comparator<K>, int (*compareByValue)(const V&, const V&) = comparator<V>>
class TreeMap : public Map<K,V> {
	TreeMap()
}

// Class that implements RED BLACK TREE iteration on top of MapIterator
template<typename K, typename V)>
class TreeMapIterator : public MapIterator<K,V> {
	TreeMapIterator(RedBlackTree<MapEntry<K,V>>* tree)
	TreeMapIterator(std::size_t total)
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Abstract class that defines iteration prototype of a SET abstract data type
template<typename T>
class SetIterator {
	SetIterator()
	virtual ~SetIterator()
	virtual const T& operator*() = 0
	virtual void operator++() = 0
	bool operator!=(const SetIterator<T>& it)
}

// Interface that defines operations one can perform on a SET abstract data type
template<typename T>
class Set {
	virtual ~Set()
	virtual void clear() = 0
	virtual bool contains(const T& value) const = 0
	virtual bool isEmpty() const = 0
	virtual const std::size_t& size() const = 0
	virtual void add(const T& value) = 0
	virtual void remove(const T& value) = 0
	virtual SetIterator<T>* begin() = 0
	virtual SetIterator<T>* end() = 0
}

// Class that implements HASH TABLE data structure on top of SET abstract data type
template<typename T, int (*compare)(const T&,const T&) = comparator<T>, std::size_t (*hash)(const T&) = hash<T>>
class HashSet : public Set<T> {
	HashSet()
	HashSet(const std::size_t& reservedSize)
}

// Class that implements HASH TABLE iteration on top of SetIterator
template<typename T>
class HashSetIterator : public SetIterator<T> {
	HashSetIterator(HashTable<T>* hashTable)
	HashSetIterator(std::size_t total)
}

// Class that implements "LINKED" HASH TABLE data structure (a HASH TABLE backed by a DOUBLY LINKED LIST to allow predictable iteration order) on top of SET abstract data type
template<typename T, int (*compare)(const T&,const T&) = comparator<T>, std::size_t (*hash)(const T&) = hash<T>>
class LinkedHashSet : public Set<T> {
	LinkedHashSet()
	LinkedHashSet(const std::size_t& reservedSize)
	void sort(bool (*comparator) (const T&, const T&))
}

// Class that implements "LINKED" HASH TABLE iteration on top of SetIterator
template<typename T>
class LinkedHashSetIterator : public SetIterator<T> {
	LinkedHashSetIterator(LinkedHashTable<T>* set)
	LinkedHashSetIterator(std::size_t total)
}

// Class that implements RED BLACK TREE data structure on top of SET abstract data type
template<typename T, int (*compare)(const T&,const T&) = comparator<T>>
class TreeSet : public Set<T> {
	TreeSet()
}

// Class that implements RED BLACK TREE iteration on top of SetIterator
template<typename T>
class TreeSetIterator : public SetIterator<T> {
	TreeSetIterator(RedBlackTree<T>* tree)
	TreeSetIterator(std::size_t total)
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// Interface that defines operations one can perform on a CONTAINER abstract data type
template<typename T>
class Container {
	virtual ~Container()
	virtual void clear() = 0
	virtual const std::size_t& size() const = 0
	virtual bool isEmpty() const = 0
	virtual const T& peek() const = 0
	virtual T pop() = 0
	virtual void push(const T& item) = 0
}

// Class that implements QUEUE data structure on top of CONTAINER abstract data type
template<typename T>
class Queue: public Container<T> {
	Queue()
}

// Class that implements STACK data structure on top of CONTAINER abstract data type
template<typename T>
class Stack: public Container<T> {
	Stack()
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// Class that implements a node in a TREE data structure along with operations it can perform
template<typename T>
class TreeNode {
	TreeNode(const T& data)
	~TreeNode()
	void setParent(TreeNode<T>* const& parent)
	TreeNode<T>*& getParent()
	void setData(const T& data)
	const T& getData() const
	const ArrayList<TreeNode<T>*>*& getChildren()
	void addChild(TreeNode<T>*& node)
	void removeChild(TreeNode<T>*& node)
	void removeChildren()
	bool isDescendantOf(TreeNode<T>*& node)
	bool isAncestorOf(TreeNode<T>*& node)
	TreeNode<T>* getRoot()
	ArrayList<TreeNode<T>*>* getAncestors()
	ArrayList<TreeNode<T>*>* getDescendants()
	std::size_t getSize() const
	std::size_t getHeight() const
	std::size_t getDepth() const
}

// Class that implements operations one can perform on a TREE data structure (abstract data type)
template<typename T>
class Tree {
	explicit Tree(const T& data)
	virtual ~Tree()
	TreeNode<T>* getRoot()
	std::size_t getSize()
	std::size_t getHeight()
	virtual TreeNode<T>* createNode(const T& data, TreeNode<T>*& parent)
	virtual void removeNode(TreeNode<T>*& node)
	virtual void removeBranch(TreeNode<T>*& node)
}

// Class that specializes TREE data structure with node value uniqueness guarantee, by virtue of being backed by a HASH TABLE
template<typename T, int (*compare)(const T&, const T&) = comparator<T>, std::size_t (*hash)(const T&) = hash<T>>
class UniqueTree : public Tree<T> {
	TreeNode<T>* search(const T& data)
	bool contains(const T& data) const
}

// Interface that defines prototype of a node visitor while TREE iteration is performed
template<typename T>
class TreeNodeVisitor {
	virtual ~TreeNodeVisitor()
	virtual bool visit(TreeNode<T>*& element) = 0
}

// Function that implements pre-order tree iteration
template<typename T>
inline void PreOrderTreeIterator(TreeNode<T>* node, TreeNodeVisitor<T>*  = comparator<Tvisitor)

// Function that implements post-order tree iteration
template<typename T>
inline void PostOrderTreeIterator(TreeNode<T>* node, TreeNodeVisitor<T>* visitor)

// Function that implements level-order tree iteration
template<typename T>
inline void LevelOrderTreeIterator(TreeNode<T>* root, TreeNodeVisitor<T>* visitor)

// Function that implements level-order tree iteration with limited depth
template<typename T>
inline void LevelOrderTreeIterator(TreeNode<T>* root, std::size_t depth, TreeNodeVisitor<T>* visitor)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// Class that implements a vertex in a unweighted GRAPH abstract data type along with operations it can perform
template<typename T>
class GraphVertex {
	GraphVertex(const T& data) 
	~GraphVertex()
	void setData(const T& data)
	const T& getData() const
	const std::vector<GraphVertex<T>*>& getEdges() const
	bool isEdge(GraphVertex<T>*& vertex) const
	void addEdge(GraphVertex<T>*& vertex)
	void removeEdge(GraphVertex<T>*& vertex)
}

// Interface that defines operations one can perform on a unweighted GRAPH abstract data type
template<typename T>
class Graph {
	virtual ~Graph() {}
	virtual GraphVertex<T>* createVertex(const T& data) = 0
	virtual void removeVertex(GraphVertex<T>*& vertex) = 0
	virtual std::size_t getSize() const = 0
	virtual bool isConnected(GraphVertex<T>*& left, GraphVertex<T>*& right) const = 0
	virtual std::vector<GraphVertex<T>*> getShortestPath(GraphVertex<T>*& left, GraphVertex<T>*& right) const = 0
}

// Class that implements an ADJANCENCY LIST data structure backed by a DYNAMIC ARRAY (to let vertex values be duplicate) on top of unweighted GRAPH abstract data type. 
template<typename T, int (*compare)(const T&, const T&) = comparator<T>>
class NonDirectedGraph : public Graph<T> {
	bool contains(const T& data, int (*comparator)(const T&, const T&)) const
	std::vector<GraphVertex<T>*> search(const T& data, int (*comparator)(const T&, const T&)) const
}

// Class that implements an ADJANCENCY LIST data structure backed by a HASH TABLE (to guarantee vertex value uniqueness) on top of unweighted GRAPH abstract data type.
template<typename T, int (*compare)(const T&, const T&), std::size_t (*hash)(const T&)>
class DirectedGraph : public Graph<T> {
	bool contains(const T& data) const
	GraphVertex<T>* search(const T& data)
}

// Interface that defines prototype of a node visitor while unweighted GRAPH iteration is performed
template<typename T>
class GraphVertexVisitor {
	virtual ~GraphVertexVisitor()
	virtual void visit(GraphVertex<T>* const& element) = 0
}

// Function that implements breadth-first-search unweighted GRAPH iteration
template<typename T>
inline void BreadthFirstSearchGraphIterator(GraphVertex<T>* vertex, GraphVertexVisitor<T>* visitor)

// Function that implements depth-first-search unweighted GRAPH iteration
template<typename T>
inline void DepthFirstSearchGraphIterator(GraphVertex<T>* vertex, GraphVertexVisitor<T>* visitor)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// Class that implements a vertex in a weighted GRAPH abstract data type along with operations it can perform
template<typename T, typename W>
class WeightedGraphVertex {
	WeightedGraphVertex(const T& data)
	~WeightedGraphVertex()
	void setData(const T& data)
	const T& getData() const
	const std::vector<WeightedGraphEdge<T,W>*>& getEdges() const
	bool isEdge(WeightedGraphVertex<T,W>*& vertex) const
	const W& getEdgeWeight(WeightedGraphVertex<T,W>*& vertex) const
	void setEdgeWeight(WeightedGraphVertex<T,W>*& vertex, const W& weight)
	void addEdge(WeightedGraphVertex<T,W>*& vertex, const W& weight)
	void removeEdge(WeightedGraphVertex<T,W>*& vertex)
}

// Struct that defines the vertex/weight pair that typifies weighted GRAPH edges
template<typename T, typename W>
struct WeightedGraphEdge {
	WeightedGraphVertex<T,W>* vertex;
	W weight;
}

// Interface that defines operations one can perform on a weighted GRAPH abstract data type
template<typename T, typename W>
class WeightedGraph {
	virtual WeightedGraphVertex<T,W>* createVertex(const T& data) = 0
	virtual void removeVertex(WeightedGraphVertex<T,W>*& vertex) = 0
	virtual std::size_t getSize() const = 0
	virtual bool isConnected(WeightedGraphVertex<T,W>*& left, WeightedGraphVertex<T,W>*& right) const = 0
	virtual std::vector<WeightedGraphEdge<T,W>*> getShortestPath(WeightedGraphVertex<T,W>*& left, WeightedGraphVertex<T,W>*& right) const = 0
}

// Class that implements an ADJANCENCY LIST data structure backed by a DYNAMIC ARRAY (to let vertex values be duplicate) on top of weighted GRAPH abstract data type. 
template<typename T, typename W>
class NonUniqueWeightedGraph : public WeightedGraph<T,W> {
	bool contains(const T& data, int (*comparator)(const T&, const T&)) const
	std::vector<WeightedGraphVertex<T,W>*> search(const T& data, int (*comparator)(const T&, const T&)) const
}

// Class that implements an ADJANCENCY LIST data structure backed by a HASH TABLE (to guarantee vertex value uniqueness) on top of weighted GRAPH abstract data type.
template<typename T,typename W, int (*compare)(const T&, const T&), std::size_t (*hash)(const T&)>
class UniqueWeightedGraph : public WeightedGraph<T,W> {
	bool contains(const T& data) const
	WeightedGraphVertex<T,W>* search(const T& data)
}

// Interface that defines prototype of a node visitor while weighted GRAPH iteration is performed
template<typename T, typename W>
class WeightedGraphVertexVisitor {
	virtual ~WeightedGraphVertexVisitor()
	virtual bool visit(WeightedGraphVertex<T,W>* const& element) = 0
	virtual bool isVisited(WeightedGraphVertex<T,W>* const& element) = 0
}

// Function that implements breadth-first-search weighted GRAPH iteration
template<typename T, typename W>
inline void BreadthFirstSearchGraphIterator(WeightedGraphVertex<T,W>* vertex, WeightedGraphVertexVisitor<T,W>* visitor)

// Function that implements depth-first-search weighted GRAPH iteration
template<typename T, typename W>
inline void DepthFirstSearchGraphIterator(WeightedGraphVertex<T,W>* vertex, WeightedGraphVertexVisitor<T,W>* visitor)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Enum that defines RED BLACK TREE colors
enum RedBlackTreeNodeColor { RED, BLACK }

// Struct that defines an entry in a RED BLACK TREE node
template<typename T>
struct RedBlackTreeNode {
	T data;
	RedBlackTreeNode<T>* left;
	RedBlackTreeNode<T>* right;
	RedBlackTreeNode<T>* parent;
	RedBlackTreeNodeColor color;
}

// Class that implements a RED BLACK TREE specialization of self-balancing BINARY SEARCH TREE data structure
template<typename T>
class RedBlackTree {
	RedBlackTree(int (*comparator)(const T&,const T&))
	~RedBlackTree()
	bool hasNode(const T& value) const
	const T* getNodeValue(const T& value) const
	void deleteNode(const T& value)
	void insertNode(const T& value)
	const std::size_t& getSize() const
	bool hasMatches(const T& value, int (*custom_comparator)(const T&,const T&))
	void deleteMatches(const T& value, int (*custom_comparator)(const T&,const T&))
	RedBlackTreeNode<T>* min() 
	RedBlackTreeNode<T>* getNextNode(RedBlackTreeNode<T>* node)
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// Struct that defines an entry in a HASH TABLE node
template<typename T>
struct HashTableEntry {
	std::size_t hash;
	T data;
	HashTableEntry<T>* next;
}

// Class that implements a HASH TABLE where iteration order is unpredictable
template<typename T>
class HashTable {
	HashTable(int (*comparator)(const T&,const T&), std::size_t (*hasher)(const T&))
	HashTable(int (*comparator)(const T&,const T&), std::size_t (*hasher)(const T&), const std::size_t& reservedSize)
	~HashTable()
	void clear()
	bool contains(const T& value) const
	bool contains(const T& value, int (*customCompare)(const T&,const T&)) const
	bool isEmpty() const
	const std::size_t& size() const
	const T* get(const T& value) const
	void set(const T& value)
	void remove(const T& value)
	void remove(const T& value, int (*customCompare)(const T&,const T&))
	std::size_t getMinBucket() const
	HashTableEntry<T>* getCurrentNode(const std::size_t& bucket_number, const std::size_t& position) const
	void nextNode(std::size_t& bucket_number, std::size_t& position)
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// Struct that defines an entry in a "LINKED" HASH TABLE node
template<typename T>
struct LinkedHashTableEntry {
	std::size_t hash;
	T data;
	// singly linked list for traversal @ bucket
	LinkedHashTableEntry<T>* nextInBucket;
	// doubly linked list for traversal in insertion order
	LinkedHashTableEntry<T>* previous;
	LinkedHashTableEntry<T>* next;
}

// Class that implements a HASH TABLE backed by a DOUBLY LINKED LIST to make iteration order predictable
template<typename T>
class LinkedHashTable {
public:
	LinkedHashTable(int (*comparator)(const T&,const T&), std::size_t (*hasher)(const T&))
	LinkedHashTable(int (*comparator)(const T&,const T&), std::size_t (*hasher)(const T&), const std::size_t& reservedSize)
	~LinkedHashTable()
	void clear()
	bool contains(const T& value) const
	bool contains(const T& value, int (*customCompare)(const T&,const T&)) const
	bool isEmpty() const
	const std::size_t& size() const
	const T* get(const T& value) const
	void set(const T& value)
	void remove(const T& value)
	void remove(const T& value, int (*customCompare)(const T&,const T&))
	LinkedHashTableEntry<T>*& getHead()
	LinkedHashTableEntry<T>*& getTail()
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Function implementing a comparator that by default does nothing
template<typename T>
inline int comparator(const T& left, const T& right)

// Function implementing a comparator for LONG data type
template<>
inline int comparator(const long& left, const long& right)

// Function implementing a comparator for CHAR* data type
template<>
inline int comparator(char* const& left, char* const& right)

// Function specializing comparator for ASC sorting
template<typename T>
bool compareAsc(const T& left, const T& right)

// Function specializing comparator for DESC sorting
template<typename T>
bool compareDesc(const T& left, const T& right)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// Function implementing a hasher (requirement of HASH TABLE) that by default does nothing
template<typename T>
inline std::size_t hash(const T& item)

// Function implementing a hasher (requirement of HASH TABLE) for LONG data type
template<>
inline std::size_t hash(const long& item)

// Function implementing a hasher (requirement of HASH TABLE) for CHAR* data type
template<>
inline std::size_t hash(const char*& item)
