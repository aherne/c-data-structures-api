// Enum that defines RED BLACK TREE colors
enum RedBlackTreeNodeColor { RED, BLACK }

// Struct that defines an entry in a RED BLACK TREE
template<typename T>
struct RedBlackTreeNode {
	T data;
	RedBlackTreeNode<T>* left;
	RedBlackTreeNode<T>* right;
	RedBlackTreeNode<T>* parent;
	RedBlackTreeNodeColor color;
}

// Class that implements a RED BLACK TREE specialization of self-balancing BINARY SEARCH TREE data structure
template<typename T>
class RedBlackTree {
	// Creates a RBT by comparator
	RedBlackTree(int (*comparator)(const T&,const T&))
	// Deallocates all elements in RBT from heap
	~RedBlackTree()
	// Gets value in RBT matching that of input
	T* getNodeValue(const T& value) const
	// Adds node to RBT by value
	void insertNode(const T& value)
	// Gets number of nodes in RBT
	const std::size_t& getSize() const
	// Checks if RBT contains node by value
	bool hasNode(const T& value) const
	// Checks if RBT contains node by value and comparator
	bool hasMatches(const T& value, int (*custom_comparator)(const T&,const T&))
	// Removes node from RBT by value
	void deleteNode(const T& value)
	// Removes node from RBT by value and comparator 
	void deleteMatches(const T& value, int (*custom_comparator)(const T&,const T&))
	// Gets root node in RBT for iteration
	RedBlackTreeNode<T>* min() 
	// Gets next node in RBT after input node for iteration
	RedBlackTreeNode<T>* getNextNode(RedBlackTreeNode<T>* node)
}

// Struct that defines an entry in a HASH TABLE
template<typename T>
struct HashTableEntry {
	std::size_t hash;
	T data;
	HashTableEntry<T>* next;
}

// Class that implements a HASH TABLE where iterati"LINKED" on order is unpredictable
template<typename T>
class HashTable {
	// Creates a hash table by comparator and hashing function of unknown initial size
	HashTable(int (*comparator)(const T&,const T&), std::size_t (*hasher)(const T&))
	// Creates a hash table by comparator and hashing function of known initial size
	HashTable(int (*comparator)(const T&,const T&), std::size_t (*hasher)(const T&), const std::size_t& reservedSize)
	// Deallocates all elements in hash table from heap
	~HashTable()
	// Clears hash table of all elements
	void clear()
	// Checks if hash table contains element by value
	bool contains(const T& value) const
	// Checks if hash table contains element by value and comparator
	bool contains(const T& value, int (*customCompare)(const T&,const T&)) const
	// Checks if hash table is empty
	bool isEmpty() const
	// Gets number of elements in hash table
	const std::size_t& size() const
	// Gets value in hash table matching that of input
	T* get(const T& value) const
	// Adds element to hash table by value
	void set(const T& value)
	// Removes element from hash table by value
	void remove(const T& value)
	// Removes element from hash table by value and comparator
	void remove(const T& value, int (*customCompare)(const T&,const T&))
	// Gets bucket number to start iteration from
	std::size_t getMinBucket() const
	// Gets current element while iterating
	HashTableEntry<T>* getCurrentNode(const std::size_t& bucket_number, const std::size_t& position) const
	// Gets next node for iterating
	void nextNode(std::size_t& bucket_number, std::size_t& position)
}

// Struct that defines an entry in a "LINKED" HASH TABLE
template<typename T>
struct LinkedHashTableEntry {
	std::size_t hash;
	T data;
	LinkedHashTableEntry<T>* nextInBucket;
	LinkedHashTableEntry<T>* previous;
	LinkedHashTableEntry<T>* next;
}

// Class that implements a HASH TABLE backed by a DOUBLY LINKED LIST to make iteration order predictable
template<typename T>
class LinkedHashTable {
	// Creates a linked hash table by comparator and hashing function of unknown initial size
	LinkedHashTable(int (*comparator)(const T&,const T&), std::size_t (*hasher)(const T&))
	// Creates a linked hash table by comparator and hashing function of known initial size
	LinkedHashTable(int (*comparator)(const T&,const T&), std::size_t (*hasher)(const T&), const std::size_t& reservedSize)
	// Deallocates all elements in linked hash table from heap
	~LinkedHashTable()
	// Clears linked hash table of all elements
	void clear()
	// Checks if linked hash table contains element by value
	bool contains(const T& value) const
	// Checks if linked hash table contains element by value and comparator
	bool contains(const T& value, int (*customCompare)(const T&,const T&)) const
	// Checks if linked hash table is empty
	bool isEmpty() const
	// Gets number of elements in linked hash table
	const std::size_t& size() const
	// Gets value in linked hash table matching that of input
	T* get(const T& value) const
	// Adds element to linked hash table by value
	void set(const T& value)
	// Removes element from linked hash table by value
	void remove(const T& value)
	// Removes element from linked hash table by value and comparator
	void remove(const T& value, int (*customCompare)(const T&,const T&))
	// Gets head to start iterating from
	LinkedHashTableEntry<T>*& getHead()
	// Gets tail to stop iterating at
	LinkedHashTableEntry<T>*& getTail()
}