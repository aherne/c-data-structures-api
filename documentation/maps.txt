// Interface that defines operations one can perform on an ASSOCIATIVE ARRAY abstract data type
template<typename K, typename V>
class Map {
	// Deletes elements inside from heap memory
	virtual ~Map()
	// Gets value in associative array by key
	virtual const VALUE& operator[](const KEY& index) = 0
	// Clears associative array of all elements
	virtual void clear() = 0
	// Checks if associative array contains key
	virtual bool containsKey(const K&) const = 0
	// Checks if associative array contains value
	virtual bool containsValue(const V&) const = 0
	// Checks if associative array is empty
	virtual bool isEmpty() const = 0
	// Gets associative array size
	virtual const std::size_t& size() const = 0
	// Gets value in associative array by key
	virtual const V& get(const K&) const = 0
	// Sets value in associative array by key
	virtual void set(const K&, const V&) = 0
	// Removes element from associative array by key
	virtual void removeKey(const K&) = 0
	// Removes element from associative array by value
	virtual void removeValue(const V&) = 0
	// Returns an iterator to the first element of map 
	virtual MapIterator<K,V>* begin() = 0
	// Returns an iterator to the element following last element of map
	virtual MapIterator<K,V>* end() = 0
}

// Forward iterator prototype for ASSOCIATIVE ARRAY abstract data type, hiding data structure on top
template<typename K, typename V>
class MapIterator {
	// constructs iterator, setting offset
	MapIterator()
	// virtual destructor used when iterator is deallocated
	virtual ~MapIterator()	
	// dereferencing operator required when accessing current element
	virtual const std::pair<K, V> operator*() = 0
	// advance operator required when iterating
	virtual void operator++() = 0
	// difference operator required when iterating
	bool operator!=(const MapIterator<K,V>& it)
}

// Struct that defines the key/value pair that typifies ASSOCIATIVE ARRAY entries
template<typename K, typename V>
struct MapEntry {
	K key;
	V value;
}

// Class that implements HASH TABLE data structure on top of ASSOCIATIVE ARRAY abstract data type
template<typename K, typename V, int (*compareByKey)(const K&, const K&) = comparator<K>, std::size_t (*hash)(const K&) = hash<K>, int (*compareByValue)(const V&, const V&) = comparator<V>>
class HashMap : public Map<K,V> {
	// constructs a HASH TABLE of unknown initial size
	HashMap()
	// constructs a HASH TABLE of known size
	HashMap(const std::size_t& reservedSize)
}

// Forward iterator for HASH TABLE data structure built on top of ASSOCIATIVE ARRAY iterator prototype
template<typename K, typename V>
class HashMapIterator : public MapIterator<K,V> {
	// constructs an iterator at start position when "begin" is called
	HashMapIterator(HashTable<MapEntry<K,V>>* hashTable)
	// constructs an iterator at end position when "end" is called
	HashMapIterator(std::size_t total)
}

// Class that implements "LINKED" HASH TABLE data structure (a HASH TABLE backed by a DOUBLY LINKED LIST to allow predictable iteration order) on top of ASSOCIATIVE ARRAY abstract data type
template<typename K, typename V, int (*compareByKey)(const K&, const K&) = comparator<K>, std::size_t (*hash)(const K&) = hash<K>, int (*compareByValue)(const V&, const V&) = comparator<V>>
class LinkedHashMap : public Map<K,V> {
	// constructs a "LINKED" HASH TABLE of unknown initial size
	LinkedHashMap()
	// constructs a "LINKED" HASH TABLE of known size
	LinkedHashMap(const std::size_t& reservedSize)
	// sorts elements inside by key comparator
	void sortByKey(bool (*comparator) (const K&, const K&))
	// sorts elements inside by value comparator
	void sortByValue(bool (*comparator) (const V&, const V&))
}

// Forward iterator for "LINKED" HASH TABLE data structure built on top of ASSOCIATIVE ARRAY iterator prototype
template<typename K, typename V)>
class LinkedHashMapIterator : public MapIterator<K,V> {
	// constructs an iterator at start position when "begin" is called
	LinkedHashMapIterator(LinkedHashTable<MapEntry<K,V>>* map)
	// constructs an iterator at end position when "end" is called
	LinkedHashMapIterator(std::size_t total)
}

// Class that implements RED BLACK TREE data structure on top of ASSOCIATIVE ARRAY abstract data type
template<typename K, typename V, int (*compareByKey)(const K&, const K&) = comparator<K>, int (*compareByValue)(const V&, const V&) = comparator<V>>
class TreeMap : public Map<K,V> {
	// constructs a RED BLACK TREE of unknown initial size
	TreeMap()
}

// Forward iterator for RED BLACK TREE data structure built on top of ASSOCIATIVE ARRAY iterator prototype
template<typename K, typename V)>
class TreeMapIterator : public MapIterator<K,V> {
	// constructs an iterator at start position when "begin" is called
	TreeMapIterator(RedBlackTree<MapEntry<K,V>>* tree)
	// constructs an iterator at end position when "end" is called
	TreeMapIterator(std::size_t total)
}