// Interface that defines operations one can perform on an ASSOCIATIVE ARRAY abstract data type
template<typename K, typename V>
class Map {
	virtual ~Map()
	virtual void clear() = 0
	virtual bool containsKey(const K&) const = 0
	virtual bool containsValue(const V&) const = 0
	virtual bool isEmpty() const = 0
	virtual const std::size_t& size() const = 0
	virtual const V& get(const K&) const = 0
	virtual void set(const K&, const V&) = 0
	virtual void removeKey(const K&) = 0
	virtual void removeValue(const V&) = 0
	virtual MapIterator<K,V>* begin() = 0
	virtual MapIterator<K,V>* end() = 0
}

// Abstract class that defines iteration prototype of an ASSOCIATIVE ARRAY abstract data type
template<typename K, typename V>
class MapIterator {
	MapIterator()
	virtual ~MapIterator()
	virtual const std::pair<K, V> operator*() = 0
	virtual void operator++() = 0
	bool operator!=(const MapIterator<K,V>& it)
}

// Struct that defines the key/value pair that typifies ASSOCIATIVE ARRAY entries
template<typename K, typename V>
struct MapEntry {
	K key;
	V value;
}

// Class that implements HASH TABLE data structure on top of ASSOCIATIVE ARRAY abstract data type
template<typename K, typename V, int (*compareByKey)(const K&, const K&) = comparator<K>, std::size_t (*hash)(const K&) = hash<K>, int (*compareByValue)(const V&, const V&) = comparator<V>>
class HashMap : public Map<K,V> {
	HashMap()
	HashMap(const std::size_t& reservedSize)
}

// Class that implements HASH TABLE iteration on top of MapIterator
template<typename K, typename V>
class HashMapIterator : public MapIterator<K,V> {
	HashMapIterator(HashTable<MapEntry<K,V>>* hashTable)
	HashMapIterator(std::size_t total)
}

// Class that implements "LINKED" HASH TABLE data structure (a HASH TABLE backed by a DOUBLY LINKED LIST to allow predictable iteration order) on top of ASSOCIATIVE ARRAY abstract data type
template<typename K, typename V, int (*compareByKey)(const K&, const K&) = comparator<K>, std::size_t (*hash)(const K&) = hash<K>, int (*compareByValue)(const V&, const V&) = comparator<V>>
class LinkedHashMap : public Map<K,V> {
	LinkedHashMap(const std::size_t& reservedSize)
	LinkedHashMap()
	void sortByKey(bool (*comparator) (const K&, const K&))
	void sortByValue(bool (*comparator) (const V&, const V&))
}

// Class that implements "LINKED" HASH TABLE iteration on top of MapIterator
template<typename K, typename V)>
class LinkedHashMapIterator : public MapIterator<K,V> {
	LinkedHashMapIterator(LinkedHashTable<MapEntry<K,V>>* map)
	LinkedHashMapIterator(std::size_t total)
}

// Class that implements RED BLACK TREE data structure on top of ASSOCIATIVE ARRAY abstract data type
template<typename K, typename V, int (*compareByKey)(const K&, const K&) = comparator<K>, int (*compareByValue)(const V&, const V&) = comparator<V>>
class TreeMap : public Map<K,V> {
	TreeMap()
}

// Class that implements RED BLACK TREE iteration on top of MapIterator
template<typename K, typename V)>
class TreeMapIterator : public MapIterator<K,V> {
	TreeMapIterator(RedBlackTree<MapEntry<K,V>>* tree)
	TreeMapIterator(std::size_t total)
}