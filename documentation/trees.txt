// Class that implements a NODE in a TREE data structure along with operations it can perform
template<typename T>
class TreeNode {
	// Creates a node by value inside
	TreeNode(const T& data)
	// Clears node children from heap memory
	~TreeNode()
	// Sets parent node
	void setParent(TreeNode<T>* const& parent)
	// Gets parent node
	TreeNode<T>*& getParent()
	// Sets value inside node
	void setData(const T& data)
	// Gets value inside node
	const T& getData() const
	// Gets all node children
	ArrayList<TreeNode<T>*>* const& getChildren()
	// Adds child node
	void addChild(TreeNode<T>*& node)
	// Removes child node
	void removeChild(TreeNode<T>*& node)
	// Removes all child nodes
	void removeChildren()
	// Checks if node is descenant of another
	bool isDescendantOf(TreeNode<T>*& node)
	// Checks if node is ancestor of another
	bool isAncestorOf(TreeNode<T>*& node)
	TreeNode<T>* getRoot()
	// Gets all node ancestors
	ArrayList<TreeNode<T>*>* getAncestors()
	// Gets all node descendants
	ArrayList<TreeNode<T>*>* getDescendants()
	// Gets number of children in node
	std::size_t getSize() const
	// Gets number of edges from the current node to most distant descendant
	std::size_t getHeight() const
	// Gets number of edges from the current node to most distant ancestor
	std::size_t getDepth() const
}

// Class that implements operations one can perform on a TREE abstract data type
template<typename T>
class Tree {
	// Creates root tree node by data inside
	explicit Tree(const T& data)
	// Clears all nodes from heap memory
	virtual ~Tree()
	// Gets root node of tree
	TreeNode<T>* getRoot()
	// Gets number of nodes in tree
	std::size_t getSize()
	// Gets number of edges from root node to most distant descendant
	std::size_t getHeight()
	// Creates a tree node, child of another
	virtual TreeNode<T>* createNode(const T& data, TreeNode<T>*& parent)
	// Removes and deallocates node from tree, moving children to its parent
	virtual void removeNode(TreeNode<T>*& node)
	// Removes and deallocates node from tree along with all descendants
	virtual void removeBranch(TreeNode<T>*& node)
}

// Class that a data structure on top of TREE abstract data type that guarantees node values uniqueness
template<typename T, int (*compare)(const T&, const T&) = comparator<T>, std::size_t (*hash)(const T&) = hash<T>>
class UniqueTree : public Tree<T> {
	// Creates root tree node by data inside along with a 
	UniqueTree(const T& data)
	// Clears all nodes from heap memory
	virtual ~Tree()
	// Searches node in tree by value inside
	TreeNode<T>* search(const T& data)
	// Checks if tree contains a node by value inside
	bool contains(const T& data) const
}

// Interface that defines prototype of a node visitor while TREE iteration is performed
template<typename T>
class TreeNodeVisitor {
	// Deallocates internals from heap memory
	virtual ~TreeNodeVisitor()
	// Visits a node during iteration. If false is returned, iteration stops!
	virtual bool visit(TreeNode<T>*& element) = 0
}

// Function that implements pre-order tree iteration from start node
template<typename T>
inline void PreOrderTreeIterator(TreeNode<T>* node, TreeNodeVisitor<T>*  = comparator<Tvisitor)

// Function that implements post-order tree iteration from start node
template<typename T>
inline void PostOrderTreeIterator(TreeNode<T>* node, TreeNodeVisitor<T>* visitor)

// Function that implements level-order tree iteration from start node
template<typename T>
inline void LevelOrderTreeIterator(TreeNode<T>* root, TreeNodeVisitor<T>* visitor)

// Function that implements level-order tree iteration with limited depth from start node
template<typename T>
inline void LevelOrderTreeIterator(TreeNode<T>* root, std::size_t depth, TreeNodeVisitor<T>* visitor)